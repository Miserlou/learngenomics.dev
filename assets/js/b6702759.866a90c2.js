"use strict";(self.webpackChunklearngenomics_dev=self.webpackChunklearngenomics_dev||[]).push([[227],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return f}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),f=r,h=u["".concat(s,".").concat(f)]||u[f]||c[f]||i;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9813:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={},s="VCF Files",p={unversionedId:"genomic-file-formats/VCF-files",id:"genomic-file-formats/VCF-files",title:"VCF Files",description:"The\xa0Variant Call Format\xa0(or VCF) is the most common format for storing variants detected in next-generation sequencing data. Typically, these files will be bgzipped and indexed. Each VCF file contains a header (typically used for storing metadata) and a list of variants. Minimally, each variant contains information about the where the variant lives in the genome and a definition of the change caused by the variant. It also supports storing information about the cohort samples and which samples contain which variants (effectively a\xa0[numvariants] X [numsamples]\xa0matrix with information on every sample, variant pair.)",source:"@site/docs/04-genomic-file-formats/04-VCF-files.md",sourceDirName:"04-genomic-file-formats",slug:"/genomic-file-formats/VCF-files",permalink:"/docs/genomic-file-formats/VCF-files",draft:!1,editUrl:"https://github.com/stjude/learngenomics.dev/tree/main/docs/04-genomic-file-formats/04-VCF-files.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"BAM Files",permalink:"/docs/genomic-file-formats/BAM-files"},next:{title:"Engineering Ecosystem",permalink:"/docs/engineering-ecosystem/"}},m={},c=[],u={toc:c};function f(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"vcf-files"},"VCF Files"),(0,i.kt)("p",null,"The\xa0",(0,i.kt)("strong",{parentName:"p"},"Variant Call Format"),"\xa0(or VCF) is the most common format for storing variants detected in next-generation sequencing data. Typically, these files will be bgzipped and indexed. Each VCF file contains a header (typically used for storing metadata) and a list of variants. Minimally, each variant contains information about the where the variant lives in the genome and a definition of the change caused by the variant. It also supports storing information about the cohort samples and which samples contain which variants (effectively a\xa0","[num_variants]"," X ","[num_samples]","\xa0matrix with information on every sample, variant pair.)"),(0,i.kt)("p",null,"Concretely, the minimal VCF looks like this."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"CHROM")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"POS")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"ID")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"REF")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"ALT")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"QUAL")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"FILTER")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"INFO")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"chr1"),(0,i.kt)("td",{parentName:"tr",align:null},"114713908"),(0,i.kt)("td",{parentName:"tr",align:null},"rs11554290"),(0,i.kt)("td",{parentName:"tr",align:null},"T"),(0,i.kt)("td",{parentName:"tr",align:null},"A"),(0,i.kt)("td",{parentName:"tr",align:null},"."),(0,i.kt)("td",{parentName:"tr",align:null},"."),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"chr17"),(0,i.kt)("td",{parentName:"tr",align:null},"7683718"),(0,i.kt)("td",{parentName:"tr",align:null},"."),(0,i.kt)("td",{parentName:"tr",align:null},"C"),(0,i.kt)("td",{parentName:"tr",align:null},"CT"),(0,i.kt)("td",{parentName:"tr",align:null},"."),(0,i.kt)("td",{parentName:"tr",align:null},"."),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("p",null,"These fields describe:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Variant Location."),'\xa0Typically, the chromosome, position, reference base(s), and alternative base(s) fields are used to create an "address" of the variant in the genome using the form\xa0chrom-pos-ref-alt.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Variant Identifier."),"\xa0The ID field is used to store one or more unique identifiers for the variant. Commonly, the rs numbers from\xa0",(0,i.kt)("a",{parentName:"p",href:"https://www.ncbi.nlm.nih.gov/snp/"},"dbSNP"),"\xa0are used.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Quality of the Variant."),"\xa0A measure of confidence in the called variant or lack thereof. This field follows the common practice of encoding qualities as a Phred-scaled quality score with the formula\xa0. A score of 10 means there is a 1 in 10 chance of the call being incorrect, 20 means a 1 in 100 chance of the call being incorrect, and so on. If unknown, the value should be the missing value,\xa0a period.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Filter Status."),"\xa0This denotes the status of whether the variant passed all quality filters from the caller. If the variant passes, the value will have a value of\xa0PASS. If the variant fails any filters, the value will be a semi-colon separated list of codes for the filters. If unknown, the value should be the missing value.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Additional Information."),"\xa0A field which can contain an arbitrary number of key-value pairs separated by semicolons of the form\xa0/",(0,i.kt)("key",null),"=/",(0,i.kt)("value1",null),"[,/",(0,i.kt)("value2",null),"]",". While there are some reserved keys specified in the documentation, anything can be denoted here. If there is no additional information, this field is empty."))),(0,i.kt)("p",null,"As alluded to earlier, the VCF format is flexible in that it\xa0",(0,i.kt)("em",{parentName:"p"},"may"),"\xa0specify one or more samples and indicate whether the sample contains any of the variants specified in the file. A simplified version of this would be something like:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Chromosome")," ",(0,i.kt)("strong",{parentName:"p"},"Position")," ",(0,i.kt)("strong",{parentName:"p"},"ID")," ",(0,i.kt)("strong",{parentName:"p"},"REF")," ",(0,i.kt)("strong",{parentName:"p"},"ALT")," ",(0,i.kt)("strong",{parentName:"p"},"Sample1")," ",(0,i.kt)("strong",{parentName:"p"},"Sample2")," ",(0,i.kt)("strong",{parentName:"p"},"Sample3")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"chr1 114713908 rs11554290 T A YES NO NO\nchr17 7683718 . C CT NO YES YES"),(0,i.kt)("p",null,'However, in practice this is complicated by the fact that variants can have various genotypes (homozygous reference allele, homozygous alternate allele, or heterozygous) and evidence depth. For more information, see the "Genotype fields" section of the ',(0,i.kt)("a",{parentName:"p",href:"https://samtools.github.io/hts-specs/VCFv4.2.pdf"},"VCF specification"),"."),(0,i.kt)("p",null,"Ultimately, a VCF file is just a tab-delimited text file that could be piped into standard Unix tools for processing. Learn more about it ",(0,i.kt)("a",{parentName:"p",href:"https://samtools.github.io/hts-specs/VCFv4.3.pdf"},"here"),"."))}f.isMDXComponent=!0}}]);